#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#
# SPDX-License-Identifier: GPL-3.0
#
# DVB-S2 Transmitter

import ctypes
import os
import signal
import sys
import time
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
from datetime import datetime
from distutils.version import StrictVersion
from math import pi, sqrt
from threading import Thread

import pmt
import sip
from PyQt5 import Qt, QtCore
from gnuradio import analog
from gnuradio import blocks
from gnuradio import dtv
from gnuradio import eng_notation
from gnuradio import filter
from gnuradio import gr
from gnuradio.eng_arg import eng_float, intx
from gnuradio.fft import window
from gnuradio.filter import firdes

from gnuradio import dvbs2rx

MAX_USRP_TX_GAIN = 65
MAX_USRP_FREQ = 6e9
MIN_USRP_FREQ = 10e6


def scale_rrc_taps(taps: list, sps: int, fullscale: float) -> list:
    """Scale the RRC filter taps to satisfy a target output amplitude range

    The input to the RRC filter normally consists of BPSK/QPSK/8PSK symbols
    with unitary average energy (i.e., on the unit circle). After RRC pulse
    shaping, the filtered samples are still close to unit magnitude near the
    symbol indexes. However, in between these indexes, over the indexes filled
    up by the interpolator, the amplitude typically exceeds the +-1 range. This
    is a problem when feeding an SDR Tx interface like the USRP, which expects
    samples given as floats within +-1 unless another full-scale amplitude is
    configured at the device (via stream args).

    This function conveniently scales the RRC filter taps to achieve a target
    amplitude range. This approach is equivalent to placing a "multiply by
    constant" block after the RRC filter.

    TODO: adjust the normalization when 16APSK and 32APSK are implemented, if
    the constellation symbols are designed to exceed unit magnitude.

    Args:
        taps (list): List of RRC filter taps.
        sps (int): Oversampling ratio.
        fullscale (float): Target full-scale amplitude.

    Returns:
        list: List of scaled RRC taps.
    """

    # The peak amplitude due to RRC filtering can be predicted by an
    # upper-bound. The following is based on the method described in
    # https://dsp.stackexchange.com/a/28808:
    mag_taps = list(map(abs, taps))
    max_sum = 0
    for i in range(sps):
        sum_i = sum(mag_taps[i::sps])
        if sum_i > max_sum:
            max_sum = sum_i
    return [fullscale * x / max_sum for x in taps]


class dvbs2_tx(gr.top_block, Qt.QWidget):

    def __init__(self, options):
        gr.top_block.__init__(self, "DVB-S2 Tx", catch_exceptions=True)

        ##################################################
        # Parameters
        ##################################################
        self.frame_size = options.frame_size
        self.freq = options.freq
        self.freq_offset = options.freq_offset
        self.fullscale = 1.0 if options.fullscale is None and \
            options.sink == "usrp" else options.fullscale
        self.gold_code = options.gold_code
        self.gui = options.gui
        self.gui_out_time = options.gui_out_time or options.gui_all
        self.gui_out_freq = options.gui_out_freq or options.gui_all
        self.in_fd = options.in_fd
        self.in_file = options.in_file
        self.in_repeat = options.in_repeat
        self.out_iq_format = options.out_iq_format
        self.modcod = options.modcod
        self.out_fd = options.out_fd
        self.out_file = options.out_file
        self.pilots = options.pilots
        self.rolloff = options.rolloff
        self.rrc_delay = options.rrc_delay
        self.sink = options.sink
        self.snr = options.snr
        self.source = options.source
        self.sps = (options.samp_rate / options.sym_rate) \
            if options.samp_rate is not None else options.sps
        self.sym_rate = options.sym_rate
        self.usrp = {
            'antenna': options.usrp_antenna,
            'args': options.usrp_args,
            'channels': [0],
            'clock_source': options.usrp_clock_source,
            'gain': options.usrp_gain,
            'otw_format': options.usrp_otw_format,
            'stream_args': options.usrp_stream_args or '',
            'subdev': options.usrp_subdev,
            'sync': options.usrp_sync,
            'time_source': options.usrp_time_source,
        }

        ##################################################
        # Variables
        ##################################################
        code_rate = self.modcod.upper().replace("8PSK", "").replace("QPSK", "")
        self.code_rate = code_rate
        self.samp_rate = self.sym_rate * self.sps
        self.constellation = self.modcod.replace(code_rate, "")
        self.flowgraph_connected = False
        self.plframe_len = dvbs2rx.params.pl_info(self.constellation,
                                                  self.code_rate,
                                                  self.frame_size,
                                                  self.pilots)['plframe_len']
        self.start_time = datetime.now()
        self.uptime = datetime.now() - self.start_time

        ##################################################
        # Flowgraph
        ##################################################
        if (self.gui):
            self.setup_gui()
        source_block = self.connect_source()
        sink_block = self.connect_sink()
        self.connect_dvbs2tx(source_block, sink_block)

    def _uptime_monitoring(self, qtgui_label, period=1):
        while (True):
            self.uptime = datetime.now() - self.start_time
            Qt.QMetaObject.invokeMethod(qtgui_label, "setText",
                                        Qt.Q_ARG("QString", str(self.uptime)))
            time.sleep(period)

    def _get_time_sink(self, qtgui, name):
        time_sink = qtgui.time_sink_c(
            self.plframe_len,  # size
            self.sym_rate,  # samp_rate
            name,  # name
            1,  # number of inputs
            None  # parent
        )
        time_sink.set_update_time(0.10)
        time_sink.set_y_axis(-1, 1)

        time_sink.set_y_label('Amplitude', "")

        time_sink.enable_tags(True)
        time_sink.set_trigger_mode(qtgui.TRIG_MODE_FREE, qtgui.TRIG_SLOPE_POS,
                                   0.0, 0, 0, "")
        time_sink.enable_autoscale(True)
        time_sink.enable_grid(True)
        time_sink.enable_axis_labels(True)
        time_sink.enable_control_panel(False)
        time_sink.enable_stem_plot(False)

        labels = [
            'I', 'Q', 'Signal 3', 'Signal 4', 'Signal 5', 'Signal 6',
            'Signal 7', 'Signal 8', 'Signal 9', 'Signal 10'
        ]
        widths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        colors = [
            'blue', 'red', 'green', 'black', 'cyan', 'magenta', 'yellow',
            'dark red', 'dark green', 'dark blue'
        ]
        alphas = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
        styles = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        markers = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]

        for i in range(2):
            if len(labels[i]) == 0:
                if (i % 2 == 0):
                    time_sink.set_line_label(i, "Re{{Data {0}}}".format(i / 2))
                else:
                    time_sink.set_line_label(i, "Im{{Data {0}}}".format(i / 2))
            else:
                time_sink.set_line_label(i, labels[i])
            time_sink.set_line_width(i, widths[i])
            time_sink.set_line_color(i, colors[i])
            time_sink.set_line_style(i, styles[i])
            time_sink.set_line_marker(i, markers[i])
            time_sink.set_line_alpha(i, alphas[i])

        return time_sink

    def _get_freq_sink(self, qtgui, name, ninput=1):
        freq_sink = qtgui.freq_sink_c(
            1024,  # size
            window.WIN_BLACKMAN_hARRIS,  # wintype
            0,  # fc
            self.samp_rate,  # bw
            name,  # name
            ninput,
            None  # parent
        )
        freq_sink.set_update_time(0.10)
        freq_sink.set_y_axis(-140, 10)
        freq_sink.set_y_label('Relative Gain', 'dB')
        freq_sink.set_trigger_mode(qtgui.TRIG_MODE_FREE, 0.0, 0, "")
        freq_sink.enable_autoscale(True)
        freq_sink.enable_grid(True)
        freq_sink.set_fft_average(0.05)
        freq_sink.enable_axis_labels(True)
        freq_sink.enable_control_panel(False)
        freq_sink.set_fft_window_normalized(False)

        labels = ['Before', 'After', '', '', '', '', '', '', '', '']
        widths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        colors = [
            "blue", "red", "green", "black", "cyan", "magenta", "yellow",
            "dark red", "dark green", "dark blue"
        ]
        alphas = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]

        for i in range(ninput):
            if len(labels[i]) == 0:
                freq_sink.set_line_label(i, "Data {0}".format(i))
            else:
                freq_sink.set_line_label(i, labels[i])
            freq_sink.set_line_width(i, widths[i])
            freq_sink.set_line_color(i, colors[i])
            freq_sink.set_line_alpha(i, alphas[i])

        return freq_sink

    def _add_gui_block(self, name, gui_obj, pos):
        self.gui_blocks[name] = gui_obj

        # For compatibility with GR 3.9 and 3.10, check both pyqwidget() and
        # qwidget() from the QT GUI object.
        if hasattr(gui_obj, 'pyqwidget'):
            gui_obj_win = sip.wrapinstance(gui_obj.pyqwidget(), Qt.QWidget)
        else:
            gui_obj_win = sip.wrapinstance(gui_obj.qwidget(), Qt.QWidget)

        self.top_grid_layout.addWidget(gui_obj_win, *pos)

    def setup_gui(self):
        from gnuradio import qtgui

        Qt.QWidget.__init__(self)
        self.setWindowTitle("DVB-S2 Tx")
        qtgui.util.check_set_qss()
        try:
            self.setWindowIcon(Qt.QIcon.fromTheme('gnuradio-grc'))
        except:
            pass
        self.top_scroll_layout = Qt.QVBoxLayout()
        self.setLayout(self.top_scroll_layout)
        self.top_scroll = Qt.QScrollArea()
        self.top_scroll.setFrameStyle(Qt.QFrame.NoFrame)
        self.top_scroll_layout.addWidget(self.top_scroll)
        self.top_scroll.setWidgetResizable(True)
        self.top_widget = Qt.QWidget()
        self.top_scroll.setWidget(self.top_widget)
        self.top_layout = Qt.QVBoxLayout(self.top_widget)
        self.top_grid_layout = Qt.QGridLayout()
        self.top_layout.addLayout(self.top_grid_layout)

        self.settings = Qt.QSettings("GNU Radio", "dvbs2-tx")

        try:
            if StrictVersion(Qt.qVersion()) < StrictVersion("5.0.0"):
                self.restoreGeometry(
                    self.settings.value("geometry").toByteArray())
            else:
                self.restoreGeometry(self.settings.value("geometry"))
        except:
            pass

        ##################################################
        # Blocks
        ##################################################
        self.gui_blocks = {}
        n_rows = 1
        n_optional = self.gui_out_time + self.gui_out_freq
        n_columns = max(n_optional, 1)

        # Add labels
        self.qtgui_label = {}
        for label, var in zip(["MODCOD", "Frame Size", "Pilots", "Uptime"], [
                self.modcod,
                self.frame_size.capitalize(), "On" if self.pilots else "Off",
                str(self.uptime)
        ]):
            qtgui_label_tool_bar = Qt.QToolBar(self)
            qtgui_label_tool_bar.addWidget(Qt.QLabel(label + ": "))
            self.qtgui_label[label] = Qt.QLabel(str(var))
            qtgui_label_tool_bar.addWidget(self.qtgui_label[label])
            self.top_layout.addWidget(qtgui_label_tool_bar)

        # Keep updating the uptime label on a thread
        self.uptime_thread = Thread(target=self._uptime_monitoring,
                                    args=(self.qtgui_label["Uptime"], ),
                                    daemon=True)
        self.uptime_thread.start()

        if (self.gui_out_time):
            self._add_gui_block('time_sink_iq_out',
                                self._get_time_sink(qtgui, "IQ Output"),
                                (0, 0))

        if (self.gui_out_freq):
            pos = (0, 0) if n_optional <= 1 else (0, 1)
            self._add_gui_block('freq_sink_iq_out',
                                self._get_freq_sink(qtgui, "Output PSD"), pos)

        # Optional SDR controls
        if (self.sink == 'usrp'):
            if n_columns >= 2:
                n_rows += 1
                pos = [(1, 0), (1, 1)]
            else:
                n_rows += 2
                pos = [(1, 0), (2, 0)]

            # Gain
            qt_gain_range = qtgui.Range(0, MAX_USRP_TX_GAIN, 1,
                                        self.usrp['gain'], 200)
            gui_gain_widget = qtgui.RangeWidget(qt_gain_range,
                                                self.set_gui_gain, "Gain",
                                                "counter_slider", float,
                                                QtCore.Qt.Horizontal)
            self.top_grid_layout.addWidget(gui_gain_widget, *pos[0])

            # Center Frequency
            qt_freq_range = qtgui.Range(MIN_USRP_FREQ, MAX_USRP_FREQ, 10e6,
                                        self.freq, 200)
            gui_freq_widget = qtgui.RangeWidget(qt_freq_range,
                                                self.set_gui_freq,
                                                "Center Frequency",
                                                "counter_slider", float,
                                                QtCore.Qt.Horizontal)
            self.top_grid_layout.addWidget(gui_freq_widget, *pos[1])

        # Stretch columns and rows
        for r in range(0, n_rows):
            self.top_grid_layout.setRowStretch(r, 1)
        for c in range(0, n_columns):
            self.top_grid_layout.setColumnStretch(c, 1)

    def setup_usrp_sink(self):
        from gnuradio import uhd

        self.usrp_sink = usrp_sink = uhd.usrp_sink(
            self.usrp['args'],
            uhd.stream_args(
                cpu_format="fc32",
                otw_format=self.usrp['otw_format'],
                args=self.usrp['stream_args'],
                channels=self.usrp['channels'],
            ),
            "",
        )

        chan = 0
        if self.usrp['clock_source'] is not None:
            usrp_sink.set_clock_source(self.usrp['clock_source'], chan)
        if self.usrp['time_source'] is not None:
            usrp_sink.set_time_source(self.usrp['time_source'], chan)
        if self.usrp['subdev'] is not None:
            usrp_sink.set_subdev_spec(self.usrp['subdev'], chan)
        usrp_sink.set_samp_rate(self.samp_rate)
        usrp_sink.set_center_freq(self.freq, chan)
        usrp_sink.set_antenna(self.usrp['antenna'], chan)
        usrp_sink.set_gain(self.usrp['gain'], chan)

        # Set the device time
        if self.usrp['sync'] == 'unknown_pps':
            usrp_sink.set_time_unknown_pps(uhd.time_spec(0))
        elif self.usrp['sync'] == 'pc_clock':
            usrp_sink.set_time_now(uhd.time_spec(time.time()), uhd.ALL_MBOARDS)
        elif self.usrp['sync'] == 'pc_clock_next_pps':
            last_pps = usrp_sink.get_time_last_pps().get_real_secs()
            while (usrp_sink.get_time_last_pps().get_real_secs() == last_pps):
                time.sleep(0.05)
            usrp_sink.set_time_next_pps(uhd.time_spec(int(time.time()) + 1.0))
            time.sleep(1)
        elif self.usrp['sync'] == 'gps_time':
            usrp_sink.set_time_next_pps(
                uhd.time_spec(
                    usrp_sink.get_mboard_sensor("gps_time").to_int() + 1.0))
            time.sleep(1)

        # Get the sample rate actually set on the UHD device and adjust the
        # oversampling ratio applied by the software resampler/interpolator
        # so that the nominal symbol rate is reasonably accurate despite
        # the imperfect USRP sampling rate. NOTE this adjustment works only
        # if "connect_sink" is called before "connect_dvbs2tx".
        assert not self.flowgraph_connected, \
            "Sink must be connected before the flowgraph"
        actual_samp_rate = usrp_sink.get_samp_rate()
        self.sps = actual_samp_rate / self.sym_rate
        self.samp_rate = actual_samp_rate

        return usrp_sink

    def connect_source(self):
        """Connect the MPEG TS source

        Returns:
            block: Last block object on the source pipeline, which should
            connect to the DVB-S2 Tx input.
        """
        if (self.source == "fd"):
            source = blocks.file_descriptor_source(gr.sizeof_char, self.in_fd,
                                                   False)
        elif (self.source == "file"):
            source = blocks.file_source(gr.sizeof_char, self.in_file,
                                        self.in_repeat)
            source.set_begin_tag(pmt.PMT_NIL)
        return source

    def connect_sink(self):
        """Connect the IQ sample Sink

        Returns:
            block: First block on the sink pipeline, which should connect to
            the DVB-S2 Tx output.
        """

        if (self.sink == "fd" or self.sink == "file"):
            # First block on the pipeline
            sink = throttle = blocks.throttle(gr.sizeof_gr_complex,
                                              self.samp_rate, True)

            out_size = gr.sizeof_char if self.out_iq_format == "u8" else \
                gr.sizeof_gr_complex

            if (self.sink == "fd"):
                file_or_fd_sink = blocks.file_descriptor_sink(
                    out_size, self.out_fd)
            else:
                file_or_fd_sink = blocks.file_sink(out_size, self.out_file)

            if (self.out_iq_format == "u8"):
                # Convert the complex stream into an interleaved uchar stream.
                complex_to_float_0 = blocks.complex_to_float(1)
                multiply_const_0 = blocks.multiply_const_ff(128)
                multiply_const_1 = blocks.multiply_const_ff(128)
                add_const_0 = blocks.add_const_ff(127)
                add_const_1 = blocks.add_const_ff(127)
                float_to_uchar_0 = blocks.float_to_uchar()
                float_to_uchar_1 = blocks.float_to_uchar()
                interleaver = blocks.interleave(gr.sizeof_char, 1)
                self.connect((throttle, 0), (complex_to_float_0, 0))
                self.connect((complex_to_float_0, 0), (multiply_const_0, 0))
                self.connect((complex_to_float_0, 1), (multiply_const_1, 0))
                self.connect((multiply_const_0, 0), (add_const_0, 0),
                             (float_to_uchar_0, 0), (interleaver, 0))
                self.connect((multiply_const_1, 0), (add_const_1, 0),
                             (float_to_uchar_1, 0), (interleaver, 1))
                self.connect((interleaver, 0), (file_or_fd_sink, 0))
            else:
                self.connect((throttle, 0), (file_or_fd_sink, 0))

        elif (self.sink == "usrp"):
            sink = self.setup_usrp_sink()

        # Simulation options
        # 1) Noise
        if (self.snr is not None):
            Es = 1
            EsN0_db = self.snr
            EsN0 = 10**(EsN0_db / 10)
            N0 = Es / EsN0
            noise_source = analog.noise_source_c(analog.GR_GAUSSIAN,
                                                 sqrt(N0 * self.sps), 0)
            add_block = blocks.add_vcc(1)
            self.connect((noise_source, 0), (add_block, 1))
            self.connect((add_block, 0), (sink, 0))
            sink = add_block  # new first block on the sink pipeline

        # 2) Frequency offset
        if (self.freq_offset is not None):
            rotator_cc_0_0 = blocks.rotator_cc(
                2 * pi * (self.freq_offset / self.samp_rate), False)
            self.connect((rotator_cc_0_0, 0), (sink, 0))
            sink = rotator_cc_0_0  # new first block on the sink pipeline

        return sink

    def connect_dvbs2tx(self, source_block, sink_block):
        """Connect the DVB-S2 Tx Pipeline

        Implement the following pipeline:

        BBFRAME Processing -> BCH Enc. -> LDPC Enc. -> Interleaver ->|
                                                                    |
                                                                    |
        <- Interpolator/Filter <- PL Framer <- Modulator (Mapping) <-|

        Args:
            source_block : The block providing IQ samples into the DVB-S2 Rx.
            sink_block : The block consuming the MPEG TS output stream.


        """

        translated_params = dvbs2rx.params.translate('DVB-S2', self.frame_size,
                                                     self.code_rate,
                                                     self.constellation,
                                                     self.rolloff, self.pilots)
        (standard, frame_size, code_rate, constellation, rolloff,
         pilots) = translated_params

        bbheader = dtv.dvb_bbheader_bb(standard, frame_size, code_rate,
                                       rolloff, dtv.INPUTMODE_NORMAL,
                                       dtv.INBAND_OFF, 168, 4000000)
        bbscrambler = dtv.dvb_bbscrambler_bb(standard, frame_size, code_rate)
        bch_encoder = dtv.dvb_bch_bb(standard, frame_size, code_rate)
        ldpc_encoder = dtv.dvb_ldpc_bb(standard, frame_size, code_rate,
                                       dtv.MOD_OTHER)
        interleaver = dtv.dvbs2_interleaver_bb(frame_size, code_rate,
                                               constellation)
        xfecframe_mapper = dtv.dvbs2_modulator_bc(frame_size, code_rate,
                                                  constellation,
                                                  dtv.INTERPOLATION_OFF)
        pl_framer = dtv.dvbs2_physical_cc(frame_size, code_rate, constellation,
                                          pilots, 0)

        self.connect((source_block, 0), (bbheader, 0), (bbscrambler, 0),
                     (bch_encoder, 0), (ldpc_encoder, 0), (interleaver, 0),
                     (xfecframe_mapper, 0), (pl_framer, 0))

        # The PL framer outputs an unfiltered sequence upsampled by 2 (i.e., a
        # zero-interpolated sequence). Hence, upsample the remaining ratio
        # (sps/2) to achieve an overall oversampling of sps samples per symbol.
        interp_sps = self.sps / 2  # remaining ratio

        # Use the polyphase arbitrary resampler if the remaining interpolation
        # ratio is fractional. Otherwise, use the conventional integer-factor
        # interpolating FIR filter for better performance.
        if (interp_sps.is_integer()):
            # The RRC taps must be designed for an oversampling of sps (the
            # overall ratio) but the filter block should apply an upsampling of
            # only "sps/2" given the PL framer already upsamples by 2.
            ntaps = int(2 * self.rrc_delay * self.sps) + 1
            rrc_taps = firdes.root_raised_cosine(
                self.sps,  # gain (has to be equal to the total interp factor)
                self.sps,  # overall oversampling ratio
                1.0,  # symbol rate
                self.rolloff,
                ntaps)
            if self.fullscale is not None:
                rrc_taps = scale_rrc_taps(rrc_taps, int(self.sps),
                                          self.fullscale)
            interp_filter = filter.interp_fir_filter_ccf(
                int(interp_sps), rrc_taps)
            self.connect((pl_framer, 0), (interp_filter, 0))
        else:
            # The polyphase arbitrary resampler does not work well with the
            # upsampled sequence produced by the PL framer. Hence, first, undo
            # the PL framer's upsampling (downsample by 2). Then, interpolate
            # the resulting symbol-spaced sequence by the full sps ratio.
            downsampler = blocks.keep_m_in_n(gr.sizeof_gr_complex, 1, 2, 0)
            nfilts = 32  # typically enough for low quantization error
            ntaps = int(2 * nfilts * self.rrc_delay * self.sps) + 1
            rrc_taps = filter.firdes.root_raised_cosine(
                nfilts,  # gain (has to be equal to the number of pfb branches)
                nfilts,  # sampling rate based on 32 filters in resampler
                1.0,  # symbol rate
                self.rolloff,
                ntaps)
            if self.fullscale is not None:
                rrc_taps = scale_rrc_taps(rrc_taps, nfilts, self.fullscale)
            interp_filter = filter.pfb_arb_resampler_ccf(self.sps, rrc_taps)
            self.connect((pl_framer, 0), (downsampler, 0), (interp_filter, 0))

        # The PL framer does not declare a delay due to its upsampling-by-2
        # operation. Hence, consider the total oversampling ratio when
        # declaring the interpolator's delay below. Also, note the same delay
        # applies to both the polyphase and non-polyphase resamplers.
        interp_filter.declare_sample_delay(int(self.rrc_delay * self.sps))

        self.connect((interp_filter, 0), (sink_block, 0))

        if (self.gui):
            if (self.gui_out_time):
                self.connect((interp_filter, 0),
                             (self.gui_blocks['time_sink_iq_out'], 0))
            if (self.gui_out_freq):
                self.connect((interp_filter, 0),
                             (self.gui_blocks['freq_sink_iq_out'], 0))

        self.flowgraph_connected = True

    def setStyleSheetFromFile(self, theme):
        try:
            prefixes = [gr.prefix(), "/usr/local", "/usr"]
            found = False
            for prefix in prefixes:
                filename = os.path.join(prefix, "share", "gnuradio", "themes",
                                        theme)
                if os.path.exists(filename):
                    found = True
                    break
            if (not found):
                gr.log.error("Failed to locate theme {}".format(theme))
                return
            with open(filename) as ss:
                self.setStyleSheet(ss.read())
        except Exception as e:
            gr.log.error(str(e))

    def set_gui_gain(self, new_gain):
        if (self.sink == 'usrp'):
            self.usrp['gain'] = new_gain
            self.usrp_sink.set_gain(self.usrp['gain'], 0)

    def set_gui_freq(self, new_freq):
        self.freq = new_freq
        if (self.sink == 'usrp'):
            self.usrp_sink.set_center_freq(self.freq, 0)


def argument_parser():
    description = 'DVB-S2 Transmitter'
    parser = ArgumentParser(prog="dvbs2-tx",
                            description=description,
                            formatter_class=ArgumentDefaultsHelpFormatter)
    parser.add_argument("--frame-size",
                        type=str,
                        choices=['normal', 'short'],
                        default='normal',
                        help="FECFRAME size")
    parser.add_argument("-f",
                        "--freq",
                        type=eng_float,
                        default=eng_notation.num_to_str(float(1e9)),
                        help="Carrier or intermediate frequency in Hz")
    parser.add_argument("--gold-code", type=intx, default=0, help="Gold code")
    parser.add_argument("-m",
                        "--modcod",
                        type=str,
                        default='QPSK1/4',
                        help="MODCOD")
    parser.add_argument("--pilots",
                        action='store_true',
                        default=False,
                        help="Include pilot blocks on the PLFRAMEs")
    parser.add_argument("-r",
                        "--rolloff",
                        choices=[0.35, 0.25, 0.2],
                        type=eng_float,
                        default=eng_notation.num_to_str(float(0.2)),
                        help="Rolloff factor")
    parser.add_argument("--rrc-delay",
                        type=intx,
                        default=50,
                        help="RRC filter delay in symbol periods")
    samp_rate_group = parser.add_mutually_exclusive_group()
    samp_rate_group.add_argument(
        "-o",
        "--sps",
        type=eng_float,
        default=eng_notation.num_to_str(float(2)),
        help="Oversampling ratio in samples per symbol")
    samp_rate_group.add_argument("--samp-rate",
                                 type=eng_float,
                                 help="Sampling rate in samples per second")
    parser.add_argument("-s",
                        "--sym-rate",
                        type=eng_float,
                        default=eng_notation.num_to_str(float(1000000)),
                        help="Symbol rate in bauds")
    parser.add_argument(
        "--fullscale",
        type=float,
        help="Target full-scale amplitude for the output IQ. If undefined, "
        "defaults to unlimited for sink=fd/file and 1.0 for sink=usrp")

    gui_group = parser.add_argument_group('GUI Options')
    gui_group.add_argument("--gui",
                           action='store_true',
                           default=False,
                           help="Launch a graphical user interface (GUI).")
    gui_group.add_argument(
        "--gui-out-time",
        action='store_true',
        default=False,
        help="Add widget to display the output IQ in the time domain.")
    gui_group.add_argument(
        "--gui-out-freq",
        action='store_true',
        default=False,
        help="Add widget to display the output IQ in the frequency domain.")
    gui_group.add_argument("--gui-all",
                           action='store_true',
                           default=False,
                           help="Enable all available GUI widgets.")
    gui_group.add_argument("--gui-dark",
                           action='store_true',
                           default=False,
                           help="Launch the GUI in dark mode.")

    src_group = parser.add_argument_group('Source Options')
    src_group.add_argument("--source",
                           choices=["fd", "file"],
                           default="fd",
                           help="Source of the input MPEG transport stream")
    src_group.add_argument("--in-fd",
                           type=intx,
                           default=0,
                           help="Input file descriptor used if source=fd")
    src_group.add_argument("--in-file",
                           type=str,
                           help="Input file used if source=file")
    src_group.add_argument(
        "--in-repeat",
        action='store_true',
        default=False,
        help="Read repeatedly from the input file if source=file")

    snk_group = parser.add_argument_group('Sink Options')
    snk_group.add_argument("--sink",
                           choices=["fd", "file", "usrp"],
                           default="fd",
                           help="Sink for the output IQ sample stream")
    snk_group.add_argument("--out-fd",
                           type=intx,
                           default=1,
                           help="Output file descriptor used if sink=fd")
    snk_group.add_argument("--out-file",
                           type=str,
                           help="Output file used if sink=file")
    snk_group.add_argument("--out-iq-format",
                           choices=['fc32', 'u8'],
                           default='fc32',
                           help="Output IQ format")

    usrp_group = parser.add_argument_group('USRP Options')
    usrp_group.add_argument(
        "--usrp-args",
        type=str,
        help="USRP device address arguments as a comma-delimited string with "
        "key=value pairs")
    usrp_group.add_argument("--usrp-antenna",
                            type=str,
                            default="TX/RX",
                            help="USRP antenna")
    usrp_group.add_argument("--usrp-clock-source",
                            type=str,
                            choices=['internal', 'external', 'mimo', 'gpsdo'],
                            help="USRP clock source")
    usrp_group.add_argument("--usrp-gain",
                            type=float,
                            default=0,
                            help="USRP Tx gain")
    usrp_group.add_argument("--usrp-otw-format",
                            type=str,
                            choices=['sc16', 'sc12', 'sc8'],
                            default='sc16',
                            help="USRP over-the-wire data format")
    usrp_group.add_argument(
        "--usrp-stream-args",
        type=str,
        help="USRP Tx streaming arguments as a comma-delimited string with "
        "key=value pairs")
    usrp_group.add_argument("--usrp-subdev",
                            type=str,
                            help="USRP subdevice specification")
    usrp_group.add_argument("--usrp-sync",
                            type=str,
                            choices=[
                                'unknown_pps', 'pc_clock', 'pc_clock_next_pps',
                                'gps_time', 'none'
                            ],
                            default='unknown_pps',
                            help="USRP device time synchronization method")
    usrp_group.add_argument("--usrp-time-source",
                            type=str,
                            choices=['external', 'mimo', 'gpsdo'],
                            help="USRP time source")

    sim_group = parser.add_argument_group('Simulation Options')
    sim_group.add_argument(
        "--snr",
        type=eng_float,
        help="Signal-to-noise ratio to simulate on the output stream")
    sim_group.add_argument(
        "--freq-offset",
        type=eng_float,
        help="Frequency offset in Hz to simulate on the output stream")

    options = parser.parse_args()

    if (options.sink == "usrp" and options.usrp_args is None):
        parser.error("argument --usrp-args is required when --sink=\"usrp\"")

    return options


def main():
    options = argument_parser()

    gui_mode = options.gui
    if (gui_mode):
        if sys.platform.startswith('linux'):
            try:
                x11 = ctypes.cdll.LoadLibrary('libX11.so')
                x11.XInitThreads()
            except:
                pass

        if StrictVersion("4.5.0") <= StrictVersion(
                Qt.qVersion()) < StrictVersion("5.0.0"):
            style = gr.prefs().get_string('qtgui', 'style', 'raster')
            Qt.QApplication.setGraphicsSystem(style)
        qapp = Qt.QApplication(sys.argv)

    tb = dvbs2_tx(options)
    tb.start()

    if (gui_mode):
        if (options.gui_dark):
            tb.setStyleSheetFromFile("dark.qss")
        tb.show()
    else:
        tb.wait()

    def sig_handler(sig=None, frame=None):
        tb.stop()
        tb.wait()
        if (gui_mode):
            Qt.QApplication.quit()
        else:
            sys.exit(0)

    signal.signal(signal.SIGINT, sig_handler)
    signal.signal(signal.SIGTERM, sig_handler)

    if (gui_mode):
        timer = Qt.QTimer()
        timer.start(500)
        timer.timeout.connect(lambda: None)
        qapp.exec_()


if __name__ == '__main__':
    main()
